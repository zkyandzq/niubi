### 事件修饰符
1. .stop 阻止事件冒泡
2. .trim 去除多余空格
3. .capter 事件之间捕获  相当于 如果有两个盒子，大盒子包着小盒子，捕获会从外到内
4. .once 只执行渲染一次
5. .self 跟.stop差不多 作用在事件本身
6. .prevent 阻止默认事件进行
7. .number 转化为number类型
8. .native 事件穿透

### 事件冒泡和事件捕获
<span style="color:red">事件冒泡就是事件传播的一种机制,在事件触发后，会从最内层的元素逐级向上传播，直到最外层的元素。</span>
如果某个元素触发了一个事件，比如点击事件，那么该事件会从最内层的元素开始传播，逐级向上直到根元素，也就是文档对象
优点：事件冒泡机制的优点在于，它允许处理特定元素上的事件，同时还能处理嵌套在其中的其他元素上的事件。
缺点：不加以管理的话会导致事件被处理多次。

<span style="color:red">事件捕获就是指事件触发后，会从最外层的元素逐级向内传播，直到最内层的元素。</span>
事件捕获和事件冒泡在处理顺序上的差别在于，事件捕获在事件目标处的响应函数执行之前触发，而事件冒泡则是在事件目标处的响应函数执行完毕之后才触发

### 单向数据流
**单向数据流是一种数据流动的模式，数据只允许从一个方向流向另一个方向，而不允许另一个方向反向传递数据。**
<span style="color:"red";">简单解释单向数据流</span>
当应用程序中的数据发生改变时，这些改变只能从某个数据源、某个状态管理器或某个组件中发出，并通过一系列处理流程（如过滤、转换、计算等处理），然后最终更新应用程序的组件状态或视图。这个过程始终是单向的，即数据只能沿着一个方向流动，防止了状态混乱、数据冲突的问题。

### click(v-on)
v-on:click可以写为@click
vue中的 click点击事件  传递事件对象，和几个参数可以通过 ...agrs合并数组

### v-model:value v-bind:value
v-model:value 可以简写为 v-model
v-bind:value 可以简写为 :value
bind为单项数据绑定，从Vue实例中的数据到页面元素属性
v-model则是双向数据绑定，同时绑定了Vue实例中的数据到页面元素的属性，并将用户输入绑定回Vue实例中对应的数据。

### 事件代理

事件代理是指利用事件冒泡机制，将事件的处理委托给父级节点或更高层级的元素处理，从而减少事件处理器的数量，优化性能。

事件代理就比如是
obj ={x:100}
obj2={y:200}
通过Object.defineProperty(obj2,'x',{
    可以get(){
        return obj.x到x的数据 就是事件代理
        }
        set(value){
obj.x=value
        }
        obj2.x也会是obj.x的数值
})

### Object.defineProperty的属性
configurable：表示这个属性是否可以被删除。默认为false，设置为true则可以进行删除
enumerable：表示这个属性是否可以被枚举。默认为false，设置为true则后续可以通过遍历属性的方法获取到这个属性。
writable：表示这个属性是否可以被修改。默认为false，设置为true则后续可以进行赋值操作
value：表示这个属性的初始值。默认为undefined。
get：当这个属性被访问时，会调用这个getter函数，并返回其返回值。默认为undefined。
set：当这个属性被赋值时，会调用这个setter函数，并传入新的属性值。默认为undefined。

三个参数

第一个参数obj是要在其上定义属性的对象，第二个参数prop是要定义或修改的属性的名称，第三个参数descriptor是关于该属性的描述符对象。

### 监听属性和计算属性
一.监听属性
1.watch的监听是异步的
2.没有缓存，可以请求接口
3.有配置项,deep,immediate
4.watch监听的属性,必须在data中声明
监听属性watch：
1.当被监视的属性变化时，回调函数自动执行，进行相关操作
2.监视的属性必须存在,才能进行监视
3.两种写法:(1). new Vue时传入watch配置
(2).通过vm.$watch监听
二.计算属性
1.计算属性是同步的
2.计算属性有缓存性
3.计算属性依赖的属性值，必须在data中已经定义,或者说已存在，当依赖值发生变化时，会重新计算
4.计算属性声明的值，在data中不能存在
5.计算属性最终会出现在vm上，直接读取使用即可
6.底层借助了Objcet.defineproperty方法提供的getter和setter。
<!-- 1.要计算的属性在data中不存在，要通过data中已有属性进行计算。
2.底层借助了Object.defineproperty()方法提供的getter和setter。
3.get函数在 初次读取时会执行一次。当依赖的数据发生改变时会再次被调用
4.与methods实现相比，内部有缓存机制(复用),效率更高，调试方便。
5.(1)计算属性最终会出现在vm上,直接读取使用即可
(2)计算属性要被修改必须写set去响应修改,且set中要引起计算时依赖的数据发生改变。 -->

### 键盘事件
1.keyup - 当用户释放键盘上的上的键时触发。
2.keydown -当用户按下键盘上的键时触发
3.keypress -在用户按下键盘上的键时触发，但在解释为字符输入之前触发。
4.keyup.enter/keydown.enter -当用户按下或释放Enter键时触发。
5.keyup.space/keydown.space - 当用户按下或释放Space时触发
6.keyup.delete / keydown.delete当用户按下或释放Delete键时触发
7.keyup.tab / keydown.tab 当用户按下或释放Tab键时触发

### v-if和v-show
v-if和v-show都是控制元素的显示和隐藏
**v-if**
v-if控制元素的显示和隐藏会删除对用的Dom,当每一个显示的时候,都会重新创建dom和渲染. 
特点是
基于传入的表达式的求值来确定是否渲染对应的HTML元素
显示/隐藏 ,异步编程。
当一个大盒子使用多个v-if会根据各自的条件独立进行判断和渲染，如果有一个为true,另一个所对应的源代码前面会有一个空注释,作用是占用位置,他不会对页面渲染出现影响，他只是一种语法现象。
**v-show**
v-show是通过css来改变元素的样式进行显示隐藏
频繁切换显示隐藏使用v-show，删除添加元素使用v-if

### vue的常用指令
1.**v-bind**:用于绑定属性，使其能够根据Vue实例中数据的变化而动态更新。
2.**v-model**:用于双向数据绑定,将HTML元素的值与Vue实例中的数据进行双向数据绑定。
3.**v-if/v-else-if/v-else**:用于根据条件动态的添加或移除HTML元素，根据不同条件进行对应的操作。
4.**v-show**:用于根据条件控制HTML元素的显示和隐藏,不会影响元素的HTML结构
5.**v-for**:用于基于列表数据进行循环渲染HTML元素。
6.**v-on**:绑定事件,一般使用@进行简化。
7.**v-text/{{}}**:用于输出纯文本内容,直接渲染到页面。
8.**v-html**:用于输出HTML代码,将数据渲染成代码,在页面显示。
9.**v-pre**:用于跳过某个元素或组件的编译过程，直接输出为静态内容。
10.**v-clock**:用于防止vue实例未加载完毕,页面上暴露出一些尴尬的模板语法。

### vue中key的作用
1.虚拟DOM中key的作用:
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据[新数据]生成[新的虚拟DOM]随后Vue进行[新虚拟DOM] 与[旧虚拟DOM] 的差异比较，比较规则如下:
2.对比规则:
(1).日虚拟DOM中找到了与新虚拟DOM相同的key:D若虚拟DOM中内容没变，直接使用之前的真实DOM!2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM.
(2)旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到到页面
3，用index作为key可能会引发的问题:
1.若对数据进行:逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。
2.如果结构中还包含输入类的DOM:会产生错误DOM更新 ==> 界面有问题
4，开发中如何选择key?:
1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作,仅用于渲染列表用于展示，使用index作为key是没有问题的。

### 自定义指令
**directives用来创建自定义事件**
生命周期:
1.bind:指令第一次绑定到元素时调用。在这里可以进行一些初始化操作，例如添加事件监听器等。
2.inserted：绑定元素插入到父节点时调用。在这里可以进行一些 DOM 操作，例如设置 CSS 样式等。
3.update：指令所在组件的 VNode 更新时调用。注意，这里可能会被调用多次，但可以通过比较新旧值来避免不必要的操作。
4.componentUpdated：指令所在组件的 VNode 及其子 VNode 都更新后调用。在这里可以进行一些操作，例如处理子组件的更新等。
5.unbind：指令与元素解绑时调用。在这里可以进行一些清理操作，例如移除事件监听器等。

### ref,props,$attrs
**ref** 是用于获取组件或元素引用的方法，可以在模板中使用，也可以在组件的 JavaScript 代码中使用。ref 可以在父组件中使用来获取子组件实例和子元素引用，或在子组件中使用来获取子组件和子元素引用。
**refs** 也是用于获取元素引用的方法，不过与 ref 不同的是，refs 是在组件内部使用的，而 ref 是在组件外部使用的。refs 是一个对象，它可以存储组件内部需要引用的所有元素的引用，在组件中可以通过 this.$refs 访问到 refs 对象。和 ref 不同，refs 可以用在模板标签上，也可以用在组件和元素上。
**props** 是用来在父组件与子组件之间传递数据的方法，父组件通过 props 绑定数据到子组件，子组件通过 props 接受父组件传递的数据并进行相应的处理。
**attrs**是在父组件中传递给子组件的非prop特性和事件的对象，可以在子组件中通过‘attrs` 访问到，通常用于处理标签上的非 prop 属性和事件

### mixin
**混入**
`Mixin 是指在一个对象中混入另一个对象的属性和方法，以扩展该对象的功能。Mixin 是一种非常实用的编程模式，它可以用于把多个对象的功能组合到一起，以创建一个新的对象。

使用 Mixin 的好处是可以让代码更容易复用和维护。在多个对象之间共享相同的属性和方法时，可以通过 Mixin 来避免重复编写代码。当需要改变共享的属性和方法时，也只需要修改 Mixin 对象就可以了，这样可以大大提高代码的可读性和可维护性。`
局部引入:先引入路径在主页面使用mixin:['xxxx']
会把data中的属性合并,如果属性名,方法重复先执行App内的内容
生命周期会先执行mixin中的生命周期
在mixin内的方法也可以调用组件内的方法

### 自定义事件
不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。
你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符

自定义事件通常是指由组件通过 `$emit` 方法触发的事件。

`@`符号通常用于监听组件的内置事件

### slot插槽
默认插槽:(匿名插槽)当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。
具名插槽:带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。
作用域插槽:默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

### $nextTick
将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。

### vue的路由跳转方式
1.声明式导航 :`<router-link to="/">` 
2.编程式导航: 通过访问$router来导航 `this.$router.push(),this.$router.replace(),this.$router.go(-1)返回上一级`
3.命名路由this,$router.push({name:'user',params:{id:1}})

### vue的路由传参
1.`params传参`
params是一个对象，id是属性名，item.id是值(可以从当前组件或者Vue实例上直接取) 
通过params传递参数，如果我们想获取 id 的参数值，可以通过this.$route.params.id这种方式来得到
2.`query传参`
query 来传参，这种方式是可以解决页面刷新参数消失问题的，这种方式可以理解为是 ajax 中的 get 方法，参数是直接在 url 后面添加的，参数是可见的，所以解决页面刷新参数消失问题建议使用此方法来解决；
区别params和query传参方式，params传参刷新页面后数据会丢失,query不会


